/*
*  References:
*      https://en.wikipedia.org/wiki/Label_Propagation_Algorithm
*      http://mlg.eng.cam.ac.uk/zoubin/papers/CMU-CALD-02-107.pdf
*  Algorithm calculating lp score:
*      1. Init all unlabel node with 0 (majority label)
*      2. Find all group
*      3. Iteratively re-assign each unlabel node with
*         logit(0~1) obtained from 1 degree neighbor
*  Compile & Run:
*      g++ -O3 -std=c++11 label-propagate.cpp && time ./a.out
*  Output Column:
*      1. score
*      2. connected component size
*      3. is ground truth
*      4. group size
*      5. depth from ground truth
*      6. income edge from previous depth
*/

#include <cmath>
#include <cstdio>
#include <cassert>
#include <vector>
#include <algorithm>
#define F_NODE_NUM 81894
#define C_NODE_NUM 5539312
using namespace std;

vector<int> f2c[F_NODE_NUM];
vector<int> c2f[C_NODE_NUM];
vector<int> cc(F_NODE_NUM, -1); // connected component id
vector<int> group(F_NODE_NUM, -1); // group id
vector<double> y(F_NODE_NUM, 0); // lp score
vector<int> gt(F_NODE_NUM, false); // ground truth or not
vector<double> conf_d(F_NODE_NUM, -1);
vector<double> conf_n(F_NODE_NUM, -1);

int dfs_find_cc(const int fid, const int cc_idx) {
    int sz = 1;
    cc[fid] = cc_idx;
    for(const auto &cid : f2c[fid])
        for(const auto &next_fid : c2f[cid])
            if( cc[next_fid] == -1 )
                sz += dfs_find_cc(next_fid, cc_idx);
    return sz;
}

int dfs_find_group(const int fid, const int group_idx) {
    int sz = 1;
    group[fid] = group_idx;
    for(const auto &cid : f2c[fid])
        for(const auto &next_fid : c2f[cid])
            if( group[next_fid] == -1 && !gt[next_fid] )
                sz += dfs_find_group(next_fid, group_idx);
    return sz;
}

int main() {
    FILE *in;
    int fid, cid;
    
    // Read positive examples
    in = fopen("./dataset/positive_fid.txt", "r");
    while( fscanf(in, "%d", &fid) != EOF ) {
        y[fid] = 1;
        gt[fid] = 1;
    }
    fclose(in);
    
    // Read negative examples
    in = fopen("./dataset/negative_fid.txt", "r");
    while( fscanf(in, "%d", &fid) != EOF ) {
        y[fid] = 0;
        gt[fid] = 1;
    }
    fclose(in);
    
    // Read graph
    fprintf(stderr, "Reading ./dataset/features/graph.txt\n");
    in = fopen("./dataset/features/graph.txt", "r");
    while( fscanf(in, "%d%d", &fid, &cid) != EOF ) {
        assert(fid < F_NODE_NUM);
        assert(cid < C_NODE_NUM);
        f2c[fid].emplace_back(cid);
        c2f[cid].emplace_back(fid);
    }
    fclose(in);
    
    // Find all connected components
    int cc_num = 0;
    vector<int> cc_size;
    for(int i=0; i<F_NODE_NUM; ++i)
        if( cc[i] == -1 )
            cc_size.emplace_back(dfs_find_cc(i, cc_num++));
    
    // Find all group
    int group_num = 0;
    vector<int> group_size;
    for(int i=0; i<F_NODE_NUM; ++i)
        if( group[i] == -1 && !gt[i] )
            group_size.emplace_back(dfs_find_group(i, group_num++));
    
    // Calculate confidence
    vector<int> depth_now;
    for(int i=0; i<F_NODE_NUM; ++i)
        if( gt[i] )
            depth_now.emplace_back(i);
    int depth = 1;
    while( !depth_now.empty() ) {
        fprintf(stderr, "Processing depth %d\r", depth);
        vector<int> depth_next;
        for(const auto &fid : depth_now) {
            for(const auto &cid : f2c[fid])
                for(const auto &next_fid : c2f[cid]) {
                    if( conf_d[next_fid] == -1 && !gt[next_fid] ) {
                        conf_d[next_fid] = depth;
                        conf_n[next_fid] = 1;
                        depth_next.emplace_back(next_fid);
                    }
                    else if( conf_d[next_fid] == depth )
                        conf_n[next_fid]++;
                }
        }
        depth_now = move(depth_next);
        ++depth;
    }
    fprintf(stderr, "\n");
    
    // Calculate lp score
    for(int g_idx=0; g_idx<group_num; ++g_idx) {
        // Collect nodes of this group
        vector<int> nodes;
        for(int i=0; i<F_NODE_NUM; ++i)
            if( group[i] == g_idx )
                nodes.emplace_back(i);
        
        // Iterative re-assign value for each node of this group
        const double converge_threshold = 1e-5;
        double convergency = 1;
        while( convergency > converge_threshold ) {
            fprintf(stderr, "Processing group (%d/%d) ; Convergency %f\r", g_idx+1, group_num, convergency);
            convergency = 0;
            for(const auto &fid : nodes) {
                double logit = 0;
                for(const auto &cid : f2c[fid])
                    for(const auto &next_fid : c2f[cid]) {
                        if( next_fid == fid ) continue;
                        logit += y[next_fid] / (f2c[fid].size() * (c2f[cid].size() - 1));
                    }
                convergency = max(convergency, fabs(y[fid] - logit));
                y[fid] = logit;
            }
        }
    }
    
    // Output result
    FILE *out = fopen("./dataset/features/feature_label_propagate_score.txt", "w");
    for(int i=0; i<F_NODE_NUM; ++i) {
        double score = y[i];
        int c_sz = cc_size[cc[i]];
        int is_ground_truth = gt[i];
        int g_sz = (group[i] != -1) ? group_size[group[i]] : 0;
        int depth = conf_d[i];
        int depth_cnt = conf_n[i];
        fprintf(out, "%.4f %d %d %d %d %d\n", score, c_sz, is_ground_truth, g_sz, depth, depth_cnt);
    }
    fclose(out);
}
