import os
import time
import glob
import pickle as pkl
import scipy
import numpy as np
import pandas as pd

import features_loader

from sklearn.metrics import roc_auc_score
from sklearn.model_selection import StratifiedKFold
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsRegressor
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import AdaBoostClassifier
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier

fid_dict = pkl.load(open('./dataset/fid_dict.pkl', 'rb'))

with open('./dataset/training-set.csv') as f:
    train_row = [l.split(',') for l in f.read().strip().split('\n')]
    train_row = [[fid_dict[l[0]], int(l[1])] for l in train_row if l[0] in fid_dict]
    train_dict = dict(train_row)
    train_row = np.array(train_row)
    positive_fid = set(train_row[train_row[:, 1] == 1, 0])
    negative_fid = set(train_row[train_row[:, 1] == 0, 0])

with open('./dataset/testing-set.csv') as f:
    test_row = [l.split(',') for l in f.read().strip().split('\n')]
    test_row = [l for l in test_row if l[0] in fid_dict]

X_svd256 = features_loader.load_X_svd256()
X_svd256_train = X_svd256[:len(train_row)]
y_train = train_row[:len(train_row), 1]
print('X_svd256.shape:', X_svd256.shape)


start_time = time.time()
for ith_model in range(1000, 2000):
    target_path = './models/stacker/xgb_%d.pkl' % (ith_model)
    if not os.path.isfile(target_path):
        model = XGBClassifier(
            n_estimators=1000,
            max_depth=np.random.randint(40, 50),
            sumsample=np.random.uniform(0.6, 0.8),
            colsample_bytree=np.random.uniform(0.6, 0.8),
            max_delta_step=1,
            reg_lambda=2,
            gamma=1,
            random_state=ith_model, n_jobs=8, silent=True)
        print('=' * 60)
        print('target_path', target_path)
        print('model', model)
        skf = StratifiedKFold(n_splits=3, random_state=ith_model)
        answer = np.zeros(len(X_svd256), dtype=np.float64)
        for i_fold, (tr_idx, va_idx) in enumerate(skf.split(np.arange(len(y_train)), y_train)):
            print('fold', i_fold, end='\r')
            fold_x_tr = X_svd256_train[tr_idx]
            fold_x_va = X_svd256_train[va_idx]
            fold_y_tr = y_train[tr_idx]
            fold_y_va = y_train[va_idx]

            model.fit(fold_x_tr, fold_y_tr)
            if hasattr(model, 'predict_proba'):
                answer[va_idx] = model.predict_proba(fold_x_va)[:,1]
            else:
                answer[va_idx] = model.predict(fold_x_va)
        print('fold final', end='\r')
        model.fit(X_svd256_train, y_train)
        if hasattr(model, 'predict_proba'):
            answer[len(train_row):] = model.predict_proba(X_svd256[len(train_row):])[:,1]
        else:
            answer[len(train_row):] = model.predict(X_svd256[len(train_row):])

        pkl.dump(answer, open(target_path, 'wb'))
        print('ROCAUC', roc_auc_score(y_true=y_train, y_score=answer[:len(y_train)]))
        print('Elapsed time %.1f' % (time.time() - start_time))
        
        
    target_path = './models/stacker/rf_%d.pkl' % (ith_model)
    if not os.path.isfile(target_path):
        model = RandomForestClassifier(
            n_estimators=1000,
            max_depth=np.random.randint(40,100),
            max_features=np.random.randint(45,100),
            class_weight='balanced_subsample',
            criterion='entropy',
            oob_score=True,
            random_state=ith_model, n_jobs=8)
        print('=' * 60)
        print('target_path', target_path)
        print('model', model)
        skf = StratifiedKFold(n_splits=3, random_state=ith_model)
        answer = np.zeros(len(X_svd256), dtype=np.float64)
        for i_fold, (tr_idx, va_idx) in enumerate(skf.split(np.arange(len(y_train)), y_train)):
            print('fold', i_fold, end='\r')
            fold_x_tr = X_svd256_train[tr_idx]
            fold_x_va = X_svd256_train[va_idx]
            fold_y_tr = y_train[tr_idx]
            fold_y_va = y_train[va_idx]

            model.fit(fold_x_tr, fold_y_tr)
            if hasattr(model, 'predict_proba'):
                answer[va_idx] = model.predict_proba(fold_x_va)[:,1]
            else:
                answer[va_idx] = model.predict(fold_x_va)
        print('fold final', end='\r')
        model.fit(X_svd256_train, y_train)
        if hasattr(model, 'predict_proba'):
            answer[len(train_row):] = model.predict_proba(X_svd256[len(train_row):])[:,1]
        else:
            answer[len(train_row):] = model.predict(X_svd256[len(train_row):])

        pkl.dump(answer, open(target_path, 'wb'))
        print('ROCAUC', roc_auc_score(y_true=y_train, y_score=answer[:len(y_train)]))
        print('Elapsed time %.1f' % (time.time() - start_time))

    